package xylium

import (
	"encoding/json" // For ServeFiles PathNotFound JSON response.
	"fmt"           // For error formatting.
	"io"            // For HTMLRenderer interface.
	"os"            // For os.Stdout in logger config adjustments (NewWithConfig).
	"path/filepath" // For path cleaning and manipulation in ServeFiles.
	"runtime/debug" // For capturing stack traces on panic.
	"strings"       // For string manipulation (path normalization, joining).

	"github.com/valyala/fasthttp" // The underlying HTTP engine.
)

// HTMLRenderer defines the interface for HTML template rendering.
// Applications can implement this interface to integrate their preferred
// HTML templating engine (e.g., html/template, pongo2) with Xylium.
type HTMLRenderer interface {
	// Render writes the output of a template to the provided io.Writer.
	// 'name' is the template name, 'data' is the data to pass to the template,
	// and 'c' is the Xylium Context for potential access to request-specific info.
	Render(w io.Writer, name string, data interface{}, c *Context) error
}

// Router is the main request router for the Xylium framework.
// It manages route registration, middleware execution, request handling,
// error processing, and server configuration.
type Router struct {
	tree             *Tree        // Radix tree for efficient route matching.
	globalMiddleware []Middleware // Middleware applied to all routes.

	// PanicHandler is invoked when a panic is recovered during request processing.
	// If not set, a default handler is used.
	PanicHandler HandlerFunc
	// NotFoundHandler is invoked when no route matches the requested path.
	// If not set, a default handler is used.
	NotFoundHandler HandlerFunc
	// MethodNotAllowedHandler is invoked when a route matches the path but not the HTTP method.
	// If not set, a default handler is used.
	MethodNotAllowedHandler HandlerFunc
	// GlobalErrorHandler is the central handler for all errors returned by route handlers
	// or middleware, and for errors generated by the PanicHandler.
	// If not set, a default handler is used.
	GlobalErrorHandler HandlerFunc

	serverConfig            ServerConfig   // Configuration for the underlying fasthttp.Server.
	HTMLRenderer            HTMLRenderer   // Optional HTML template renderer.
	instanceMode            string         // Operating mode (e.g., "debug", "release") of this router instance.
	internalRateLimitStores []LimiterStore // Stores internally created rate limiter stores that need closing on shutdown.
}

// Logger returns the configured logger for this router instance.
// This logger is automatically configured (level, color, caller info) based on
// Xylium's operating mode during router initialization if it's a DefaultLogger.
// If a custom logger is provided via ServerConfig, that logger is returned as is.
func (r *Router) Logger() Logger {
	// serverConfig.Logger is guaranteed to be non-nil by NewWithConfig.
	return r.serverConfig.Logger
}

// New creates a new Router instance with default server configuration.
// The logger will be automatically configured based on the Xylium operating mode.
func New() *Router {
	return NewWithConfig(DefaultServerConfig())
}

// NewWithConfig creates a new Router instance with the provided ServerConfig.
// It performs crucial initialization steps, including mode determination, logger setup,
// and default handler assignments.
func NewWithConfig(config ServerConfig) *Router {
	updateGlobalModeFromEnvOnRouterInit()
	effectiveMode := Mode()

	// Logger initialization and configuration
	if config.Logger == nil {
		baseLogCfg := DefaultLoggerConfig() // Start with absolute defaults for the logger config.
		if config.LoggerConfig != nil {     // If user provided LoggerConfig, use its values as the base.
			userProvidedLogCfg := *config.LoggerConfig
			// Merge: take from userProvidedLogCfg if set, otherwise keep DefaultLoggerConfig values.
			if userProvidedLogCfg.Output != nil {
				baseLogCfg.Output = userProvidedLogCfg.Output
			}
			if userProvidedLogCfg.Formatter != "" {
				baseLogCfg.Formatter = userProvidedLogCfg.Formatter
			}
			// For Level, ShowCaller, UseColor, these will be primarily driven by effectiveMode,
			// but we honor user's explicit config if it's set.
			baseLogCfg.Level = userProvidedLogCfg.Level
			baseLogCfg.ShowCaller = userProvidedLogCfg.ShowCaller
			baseLogCfg.UseColor = userProvidedLogCfg.UseColor
		}

		// Now, let the effectiveMode refine certain logger settings.
		finalLogCfg := baseLogCfg
		switch effectiveMode {
		case DebugMode:
			finalLogCfg.Level = LevelDebug
			finalLogCfg.ShowCaller = true
			finalLogCfg.UseColor = true
		case TestMode:
			finalLogCfg.Level = LevelDebug
			finalLogCfg.ShowCaller = true
			finalLogCfg.UseColor = false // Typically no color for test logs.
		case ReleaseMode:
			finalLogCfg.Level = LevelInfo
			finalLogCfg.ShowCaller = false
			finalLogCfg.UseColor = false
		}
		// Ensure Formatter and Output from baseLogCfg (potentially user-defined) are preserved
		// if not directly altered by mode logic (which they currently aren't).
		finalLogCfg.Formatter = baseLogCfg.Formatter
		finalLogCfg.Output = baseLogCfg.Output
		if finalLogCfg.Output == nil { // Final safety check for output
			finalLogCfg.Output = os.Stdout
		}

		config.Logger = NewDefaultLoggerWithConfig(finalLogCfg)
		config.Logger.Debugf("Router using DefaultLogger, configured. EffectiveMode: %s, FinalLoggerConfig: %+v", effectiveMode, finalLogCfg)
	} else {
		// If a custom logger implementation is provided, skip Xylium's automatic configuration.
		config.Logger.Warnf(
			"A custom logger (type: %T) was provided. Automatic Xylium mode-based and LoggerConfig-based logger configuration is skipped.",
			config.Logger,
		)
	}

	// Initialize the router instance.
	routerInstance := &Router{
		tree:                    NewTree(),
		globalMiddleware:        make([]Middleware, 0),
		serverConfig:            config,
		instanceMode:            effectiveMode,
		internalRateLimitStores: make([]LimiterStore, 0), // Initialize the slice for internal stores.
	}

	// Set default handlers for common framework events.
	routerInstance.NotFoundHandler = defaultNotFoundHandler
	routerInstance.MethodNotAllowedHandler = defaultMethodNotAllowedHandler
	routerInstance.PanicHandler = defaultPanicHandler
	routerInstance.GlobalErrorHandler = defaultGlobalErrorHandler

	routerInstance.Logger().Infof("Xylium Router initialized (Adopting Mode: %s, Determined By: %s)", routerInstance.instanceMode, modeSource)
	return routerInstance
}

// CurrentMode returns the operating mode of this specific router instance.
func (r *Router) CurrentMode() string {
	return r.instanceMode
}

// Use adds global middleware(s) to the router's chain.
func (r *Router) Use(middlewares ...Middleware) {
	r.globalMiddleware = append(r.globalMiddleware, middlewares...)
}

// addInternalStore registers an internally created LimiterStore with the router.
// This allows the router to call Close() on these stores during graceful shutdown.
// This method is unexported and intended for internal framework use.
func (r *Router) addInternalStore(store LimiterStore) {
	if store == nil {
		return
	}
	// Basic check to prevent adding the same store instance multiple times.
	for _, existingStore := range r.internalRateLimitStores {
		if existingStore == store { // Pointer comparison.
			r.Logger().Debugf("LimiterStore (type %T) attempted to be re-registered; registration skipped.", store)
			return
		}
	}
	r.internalRateLimitStores = append(r.internalRateLimitStores, store)
	r.Logger().Debugf("Internally created LimiterStore (type %T) registered for graceful shutdown.", store)
}

// addRoute is an internal helper to register a new route.
func (r *Router) addRoute(method, path string, handler HandlerFunc, middlewares ...Middleware) {
	if path == "" {
		path = "/"
	}
	if path[0] != '/' {
		panic("xylium: path must begin with '/' (e.g., \"/users\")")
	}
	r.tree.Add(method, path, handler, middlewares...)
}

// --- HTTP Method Route Registration ---
func (r *Router) GET(path string, handler HandlerFunc, middlewares ...Middleware) {
	r.addRoute(MethodGet, path, handler, middlewares...)
}
func (r *Router) POST(path string, handler HandlerFunc, middlewares ...Middleware) {
	r.addRoute(MethodPost, path, handler, middlewares...)
}
func (r *Router) PUT(path string, handler HandlerFunc, middlewares ...Middleware) {
	r.addRoute(MethodPut, path, handler, middlewares...)
}
func (r *Router) DELETE(path string, handler HandlerFunc, middlewares ...Middleware) {
	r.addRoute(MethodDelete, path, handler, middlewares...)
}
func (r *Router) PATCH(path string, handler HandlerFunc, middlewares ...Middleware) {
	r.addRoute(MethodPatch, path, handler, middlewares...)
}
func (r *Router) HEAD(path string, handler HandlerFunc, middlewares ...Middleware) {
	r.addRoute(MethodHead, path, handler, middlewares...)
}
func (r *Router) OPTIONS(path string, handler HandlerFunc, middlewares ...Middleware) {
	r.addRoute(MethodOptions, path, handler, middlewares...)
}

// Handler is the core fasthttp.RequestHandlerFunc for the Xylium router.
func (r *Router) Handler(originalFasthttpCtx *fasthttp.RequestCtx) {
	c := acquireCtx(originalFasthttpCtx)
	c.setRouter(r)
	defer releaseCtx(c)

	var errHandler error
	requestScopedLogger := c.Logger()

	defer func() {
		if rec := recover(); rec != nil {
			requestScopedLogger.Errorf("PANIC: %v\n%s", rec, string(debug.Stack()))
			if r.PanicHandler != nil {
				c.Set("panic_recovery_info", rec)
				errHandler = r.PanicHandler(c)
			} else {
				errHandler = NewHTTPError(StatusInternalServerError, "Internal server error due to panic.").WithInternal(fmt.Errorf("panic: %v", rec))
			}
		}

		if errHandler != nil {
			if !c.ResponseCommitted() {
				if r.GlobalErrorHandler != nil {
					c.Set("handler_error_cause", errHandler)
					if globalErrHandlingErr := r.GlobalErrorHandler(c); globalErrHandlingErr != nil {
						requestScopedLogger.Errorf("CRITICAL: Error within GlobalErrorHandler: %v (while handling original error: %v)", globalErrHandlingErr, errHandler)
						c.Ctx.Response.SetStatusCode(StatusInternalServerError)
						c.Ctx.Response.SetBodyString("Internal Server Error")
						c.Ctx.Response.Header.SetContentType("text/plain; charset=utf-8")
					}
				} else { // Should not happen with default setup
					requestScopedLogger.Errorf("Error (GlobalErrorHandler is nil): %v for %s %s. Sending fallback 500.", errHandler, c.Method(), c.Path())
					c.Ctx.Response.SetStatusCode(StatusInternalServerError)
					c.Ctx.Response.SetBodyString("Internal Server Error")
					c.Ctx.Response.Header.SetContentType("text/plain; charset=utf-8")
				}
			} else {
				requestScopedLogger.Warnf("Response already committed, but an error was generated post-commitment: %v for %s %s", errHandler, c.Method(), c.Path())
			}
		} else if !c.ResponseCommitted() && c.Method() != MethodHead { // Sanity check for unhandled responses
			statusCode := c.Ctx.Response.StatusCode()
			bodyLen := len(c.Ctx.Response.Body())
			contentLengthHeader := c.Ctx.Response.Header.ContentLength()
			isEffectivelyEmptyResponse := (statusCode == 0) || (statusCode == StatusOK && bodyLen == 0 && contentLengthHeader <= 0)

			if isEffectivelyEmptyResponse && statusCode != StatusNoContent {
				if r.CurrentMode() == DebugMode {
					requestScopedLogger.Debugf(
						"Handler for %s %s completed without sending response body or error (Status: %d, BodyLen: %d, ContentLength: %d). Ensure handlers explicitly send a response or use c.NoContent().",
						c.Method(), c.Path(), statusCode, bodyLen, contentLengthHeader,
					)
				}
			}
		}
	}()

	method := c.Method()
	path := c.Path()
	nodeHandler, routeMiddleware, params, allowedMethods := r.tree.Find(method, path)

	if nodeHandler != nil {
		c.Params = params
		finalChain := nodeHandler
		for i := len(routeMiddleware) - 1; i >= 0; i-- {
			finalChain = routeMiddleware[i](finalChain)
		}
		for i := len(r.globalMiddleware) - 1; i >= 0; i-- {
			finalChain = r.globalMiddleware[i](finalChain)
		}
		c.handlers = []HandlerFunc{finalChain}
		c.index = -1
		errHandler = c.Next()
	} else {
		if len(allowedMethods) > 0 { // Path exists, but not for this method (405)
			c.Params = params
			if r.MethodNotAllowedHandler != nil {
				c.SetHeader("Allow", strings.Join(allowedMethods, ", "))
				errHandler = r.MethodNotAllowedHandler(c)
			} else { // Should use default
				errHandler = NewHTTPError(StatusMethodNotAllowed, StatusText(StatusMethodNotAllowed))
			}
		} else { // Path does not exist (404)
			if r.NotFoundHandler != nil {
				errHandler = r.NotFoundHandler(c)
			} else { // Should use default
				errHandler = NewHTTPError(StatusNotFound, StatusText(StatusNotFound))
			}
		}
	}
}

// ServeFiles serves static files from a given filesystem root directory.
func (r *Router) ServeFiles(urlPathPrefix string, fileSystemRoot string) {
	if strings.Contains(urlPathPrefix, ":") || strings.Contains(urlPathPrefix, "*") {
		panic("xylium: urlPathPrefix for ServeFiles cannot contain ':' or '*'")
	}
	cleanedFileSystemRoot, err := filepath.Abs(filepath.Clean(fileSystemRoot))
	if err != nil {
		panic(fmt.Sprintf("xylium: ServeFiles could not determine absolute path for fileSystemRoot '%s': %v", fileSystemRoot, err))
	}
	catchAllParamName := "filepath" // Parameter name for the file subpath.
	normalizedUrlPathPrefix := ""
	if urlPathPrefix != "" && urlPathPrefix != "/" {
		normalizedUrlPathPrefix = "/" + strings.Trim(urlPathPrefix, "/")
	} else if urlPathPrefix == "/" {
		normalizedUrlPathPrefix = "/" // Explicit root serving.
	}

	routePath := ""
	if normalizedUrlPathPrefix == "" || normalizedUrlPathPrefix == "/" { // Serving from application root.
		routePath = "/*" + catchAllParamName
		if normalizedUrlPathPrefix == "/" && routePath == "/*"+catchAllParamName {
			// Ensure it doesn't become //*filepath if prefix was /
			// This case is actually handled by tree.Add's normalization, but explicit here is fine.
		}
	} else { // Serving from a sub-path.
		routePath = normalizedUrlPathPrefix + "/*" + catchAllParamName
	}

	routerBaseLogger := r.Logger() // For fasthttp.FS PathNotFound callback.
	fs := &fasthttp.FS{
		Root:               cleanedFileSystemRoot,
		IndexNames:         []string{"index.html"},
		GenerateIndexPages: false, // Security: disable directory listing.
		AcceptByteRange:    true,
		Compress:           true, // Enable fasthttp's compression for static files.
		PathNotFound: func(originalFasthttpCtx *fasthttp.RequestCtx) {
			errorMsg := M{"error": "The requested static asset was not found."}
			originalFasthttpCtx.SetStatusCode(StatusNotFound)
			originalFasthttpCtx.SetContentType("application/json; charset=utf-8")
			if err := json.NewEncoder(originalFasthttpCtx.Response.BodyWriter()).Encode(errorMsg); err != nil {
				routerBaseLogger.Errorf(
					"Xylium ServeFiles: CRITICAL - Error encoding JSON for PathNotFound (URI: %s, Attempted Path: %s): %v.",
					string(originalFasthttpCtx.RequestURI()),
					string(originalFasthttpCtx.Path()), // Path fasthttp.FS attempted to serve
					err,
				)
			}
		},
	}
	fileServerHandler := fs.NewRequestHandler() // fasthttp handler for serving files.

	r.GET(routePath, func(c *Context) error {
		requestedFileSubPath := c.Param(catchAllParamName)
		// Path for fasthttp.FS must be relative to FS.Root and start with '/'.
		pathForFasthttpFS := "/" + requestedFileSubPath
		pathForFasthttpFS = filepath.Clean(pathForFasthttpFS) // Normalize (e.g., remove "..").

		if pathForFasthttpFS == "." { // Request for the root of the static prefix.
			pathForFasthttpFS = "/"
		} else if !strings.HasPrefix(pathForFasthttpFS, "/") { // Ensure leading slash.
			pathForFasthttpFS = "/" + pathForFasthttpFS
		}

		originalURI := c.Ctx.Request.RequestURI()      // Save for restoration.
		c.Ctx.Request.SetRequestURI(pathForFasthttpFS) // fasthttp.FS uses RequestURI.
		fileServerHandler(c.Ctx)                       // Delegate to fasthttp.
		c.Ctx.Request.SetRequestURIBytes(originalURI)  // Restore original URI.
		return nil                                     // Response handled by fasthttp.FS.
	})
}

// --- Route Grouping ---
// RouteGroup allows organizing routes under a common path prefix and/or shared middleware.
type RouteGroup struct {
	router     *Router
	prefix     string
	middleware []Middleware
}

// Group creates a new RouteGroup.
func (r *Router) Group(urlPrefix string, middlewares ...Middleware) *RouteGroup {
	normalizedPrefix := ""
	if urlPrefix != "" && urlPrefix != "/" {
		normalizedPrefix = "/" + strings.Trim(urlPrefix, "/")
	} else if urlPrefix == "/" {
		normalizedPrefix = "/"
	}
	groupMiddleware := make([]Middleware, len(middlewares))
	copy(groupMiddleware, middlewares) // Ensure a new slice.
	return &RouteGroup{
		router:     r,
		prefix:     normalizedPrefix,
		middleware: groupMiddleware,
	}
}

// Use adds middleware to the RouteGroup.
func (rg *RouteGroup) Use(middlewares ...Middleware) {
	rg.middleware = append(rg.middleware, middlewares...)
}

// addRoute is an internal helper for RouteGroup.
func (rg *RouteGroup) addRoute(method, relativePath string, handler HandlerFunc, middlewares ...Middleware) {
	pathSegment := ""
	if relativePath != "" && relativePath != "/" {
		pathSegment = "/" + strings.Trim(relativePath, "/")
	} else if relativePath == "/" { // e.g., group.GET("/", ...)
		if rg.prefix == "" || rg.prefix == "/" { // Root group or prefix is "/"
			pathSegment = "/"
		} else { // Prefix is e.g., "/api", relativePath is "/" -> full path is "/api"
			pathSegment = ""
		}
	}
	fullPath := rg.prefix + pathSegment
	if fullPath == "" {
		fullPath = "/"
	} // Ensure root path for Group("").GET("",...)

	allApplicableMiddleware := make([]Middleware, 0, len(rg.middleware)+len(middlewares))
	allApplicableMiddleware = append(allApplicableMiddleware, rg.middleware...)
	allApplicableMiddleware = append(allApplicableMiddleware, middlewares...)
	rg.router.addRoute(method, fullPath, handler, allApplicableMiddleware...)
}

// --- HTTP Method Registrations for RouteGroup ---
func (rg *RouteGroup) GET(relativePath string, handler HandlerFunc, middlewares ...Middleware) {
	rg.addRoute(MethodGet, relativePath, handler, middlewares...)
}
func (rg *RouteGroup) POST(relativePath string, handler HandlerFunc, middlewares ...Middleware) {
	rg.addRoute(MethodPost, relativePath, handler, middlewares...)
}
func (rg *RouteGroup) PUT(relativePath string, handler HandlerFunc, middlewares ...Middleware) {
	rg.addRoute(MethodPut, relativePath, handler, middlewares...)
}
func (rg *RouteGroup) DELETE(relativePath string, handler HandlerFunc, middlewares ...Middleware) {
	rg.addRoute(MethodDelete, relativePath, handler, middlewares...)
}
func (rg *RouteGroup) PATCH(relativePath string, handler HandlerFunc, middlewares ...Middleware) {
	rg.addRoute(MethodPatch, relativePath, handler, middlewares...)
}
func (rg *RouteGroup) HEAD(relativePath string, handler HandlerFunc, middlewares ...Middleware) {
	rg.addRoute(MethodHead, relativePath, handler, middlewares...)
}
func (rg *RouteGroup) OPTIONS(relativePath string, handler HandlerFunc, middlewares ...Middleware) {
	rg.addRoute(MethodOptions, relativePath, handler, middlewares...)
}

// Group creates a new sub-RouteGroup.
func (rg *RouteGroup) Group(relativePathPrefix string, middlewares ...Middleware) *RouteGroup {
	pathSegment := ""
	if relativePathPrefix != "" && relativePathPrefix != "/" {
		pathSegment = "/" + strings.Trim(relativePathPrefix, "/")
	} else if relativePathPrefix == "/" {
		// If parent is root or "/", child prefix "/" means new prefix is just "/"
		// If parent is "/api", child prefix "/" means new prefix is "/api" (no double slash)
		if rg.prefix == "" || rg.prefix == "/" {
			pathSegment = "/"
		} else {
			pathSegment = ""
		}
	}

	newFullPrefix := rg.prefix + pathSegment
	if newFullPrefix == "" {
		newFullPrefix = "/"
	}

	combinedMiddleware := make([]Middleware, 0, len(rg.middleware)+len(middlewares))
	combinedMiddleware = append(combinedMiddleware, rg.middleware...)
	combinedMiddleware = append(combinedMiddleware, middlewares...)
	return &RouteGroup{
		router:     rg.router,
		prefix:     newFullPrefix,
		middleware: combinedMiddleware,
	}
}
